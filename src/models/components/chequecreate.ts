/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  ContactCreate,
  ContactCreate$inboundSchema,
  ContactCreate$Outbound,
  ContactCreate$outboundSchema,
} from "./contactcreate.js";
import {
  DigitalOnly,
  DigitalOnly$inboundSchema,
  DigitalOnly$Outbound,
  DigitalOnly$outboundSchema,
} from "./digitalonly.js";
import {
  OrderMailingClass,
  OrderMailingClass$inboundSchema,
  OrderMailingClass$outboundSchema,
} from "./ordermailingclass.js";

/**
 * The recipient of this order. You can either supply the contact information inline here or provide a contact ID. PostGrid will automatically deduplicate contacts regardless of whether you provide the information inline here or call the contact creation endpoint.
 */
export type ChequeCreateTo = ContactCreate | string;

export const One = {
  Standard: "standard",
} as const;
export type One = ClosedEnum<typeof One>;

/**
 * The envelope of the cheque. If a custom envelope ID is not specified, defaults to `standard`.
 */
export type Envelope = One | string;

/**
 * The contact information of the sender. You can pass contact information inline here just like you can for the `to`.
 */
export type ChequeCreateFrom = ContactCreate | string;

/**
 * Providing this inserts a blank page at the start of the cheque with the recipient you provide here. This leaves the cheque that follows intact, which means you can use this to intercept at cheque at the redirected address and then mail it forward to the final recipient yourself. One use case for this is signing cheques at your office before mailing them out yourself.
 */
export type RedirectTo = ContactCreate | string;

/**
 * The size of the cheque.
 */
export const Size = {
  UsLetter: "us_letter",
  UsLegal: "us_legal",
} as const;
/**
 * The size of the cheque.
 */
export type Size = ClosedEnum<typeof Size>;

export const Two = {
  Cad: "CAD",
} as const;
export type Two = ClosedEnum<typeof Two>;

export const CurrencyCode1 = {
  Usd: "USD",
} as const;
export type CurrencyCode1 = ClosedEnum<typeof CurrencyCode1>;

/**
 * The currency code of the cheque. This will be set to the default currency of the bank account (`USD` for US bank accounts and `CAD` for Canadian bank accounts) if not provided. You can set this value to `USD` if you want to draw USD from a Canadian bank account or vice versa.
 */
export type CurrencyCode = CurrencyCode1 | Two;

export type ChequeCreate = {
  /**
   * These will be merged with the variables in the template or HTML you create this order with. The keys in this object should match the variable names in the template _exactly_ as they are case-sensitive. Note that these _do not_ apply to PDFs uploaded with the order.
   */
  mergeVariables?: { [k: string]: any } | undefined;
  /**
   * An optional string describing this resource. Will be visible in the API and the dashboard.
   */
  description?: string | undefined;
  /**
   * See the section on Metadata.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * This order will transition from `ready` to `printing` on the day after this date. You can use this parameter to schedule orders for a future date.
   */
  sendDate?: Date | undefined;
  /**
   * The mailing class of this order. If not provided, automatically set to `first_class`.
   */
  mailingClass?: OrderMailingClass | undefined;
  /**
   * The recipient of this order. You can either supply the contact information inline here or provide a contact ID. PostGrid will automatically deduplicate contacts regardless of whether you provide the information inline here or call the contact creation endpoint.
   */
  to: ContactCreate | string;
  /**
   * The bank account (ID) associated with the cheque.
   */
  bankAccount: string;
  /**
   * The amount of the cheque in cents.
   */
  amount: number;
  /**
   * The memo of the cheque.
   */
  memo?: string | undefined;
  /**
   * The message of the cheque.
   */
  message?: string | undefined;
  /**
   * An optional logo URL for the cheque. This will be placed next to the recipient address at the top left corner of the cheque. This needs to be a public link to an image file (e.g. a PNG or JPEG file).
   */
  logoURL?: string | undefined;
  /**
   * The number of the cheque. If you don't provide this, it will automatically be set to an incrementing number starting from 1 across your entire account, ensuring that every cheque has a unique number.
   */
  number?: number | undefined;
  /**
   * The envelope of the cheque. If a custom envelope ID is not specified, defaults to `standard`.
   */
  envelope?: One | string | undefined;
  /**
   * The digitalOnly object contains data for digital-only cheques. A watermark must be provided.
   */
  digitalOnly?: DigitalOnly | undefined;
  /**
   * The contact information of the sender. You can pass contact information inline here just like you can for the `to`.
   */
  from: ContactCreate | string;
  /**
   * Providing this inserts a blank page at the start of the cheque with the recipient you provide here. This leaves the cheque that follows intact, which means you can use this to intercept at cheque at the redirected address and then mail it forward to the final recipient yourself. One use case for this is signing cheques at your office before mailing them out yourself.
   */
  redirectTo?: ContactCreate | string | undefined;
  /**
   * The size of the cheque.
   */
  size?: Size | undefined;
  /**
   * The currency code of the cheque. This will be set to the default currency of the bank account (`USD` for US bank accounts and `CAD` for Canadian bank accounts) if not provided. You can set this value to `USD` if you want to draw USD from a Canadian bank account or vice versa.
   */
  currencyCode?: CurrencyCode1 | Two | undefined;
};

/** @internal */
export const ChequeCreateTo$inboundSchema: z.ZodType<
  ChequeCreateTo,
  z.ZodTypeDef,
  unknown
> = z.union([ContactCreate$inboundSchema, z.string()]);

/** @internal */
export type ChequeCreateTo$Outbound = ContactCreate$Outbound | string;

/** @internal */
export const ChequeCreateTo$outboundSchema: z.ZodType<
  ChequeCreateTo$Outbound,
  z.ZodTypeDef,
  ChequeCreateTo
> = z.union([ContactCreate$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeCreateTo$ {
  /** @deprecated use `ChequeCreateTo$inboundSchema` instead. */
  export const inboundSchema = ChequeCreateTo$inboundSchema;
  /** @deprecated use `ChequeCreateTo$outboundSchema` instead. */
  export const outboundSchema = ChequeCreateTo$outboundSchema;
  /** @deprecated use `ChequeCreateTo$Outbound` instead. */
  export type Outbound = ChequeCreateTo$Outbound;
}

export function chequeCreateToToJSON(chequeCreateTo: ChequeCreateTo): string {
  return JSON.stringify(ChequeCreateTo$outboundSchema.parse(chequeCreateTo));
}

export function chequeCreateToFromJSON(
  jsonString: string,
): SafeParseResult<ChequeCreateTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChequeCreateTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChequeCreateTo' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodNativeEnum<typeof One> = z.nativeEnum(One);

/** @internal */
export const One$outboundSchema: z.ZodNativeEnum<typeof One> =
  One$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
}

/** @internal */
export const Envelope$inboundSchema: z.ZodType<
  Envelope,
  z.ZodTypeDef,
  unknown
> = z.union([One$inboundSchema, z.string()]);

/** @internal */
export type Envelope$Outbound = string | string;

/** @internal */
export const Envelope$outboundSchema: z.ZodType<
  Envelope$Outbound,
  z.ZodTypeDef,
  Envelope
> = z.union([One$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Envelope$ {
  /** @deprecated use `Envelope$inboundSchema` instead. */
  export const inboundSchema = Envelope$inboundSchema;
  /** @deprecated use `Envelope$outboundSchema` instead. */
  export const outboundSchema = Envelope$outboundSchema;
  /** @deprecated use `Envelope$Outbound` instead. */
  export type Outbound = Envelope$Outbound;
}

export function envelopeToJSON(envelope: Envelope): string {
  return JSON.stringify(Envelope$outboundSchema.parse(envelope));
}

export function envelopeFromJSON(
  jsonString: string,
): SafeParseResult<Envelope, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Envelope$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Envelope' from JSON`,
  );
}

/** @internal */
export const ChequeCreateFrom$inboundSchema: z.ZodType<
  ChequeCreateFrom,
  z.ZodTypeDef,
  unknown
> = z.union([ContactCreate$inboundSchema, z.string()]);

/** @internal */
export type ChequeCreateFrom$Outbound = ContactCreate$Outbound | string;

/** @internal */
export const ChequeCreateFrom$outboundSchema: z.ZodType<
  ChequeCreateFrom$Outbound,
  z.ZodTypeDef,
  ChequeCreateFrom
> = z.union([ContactCreate$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeCreateFrom$ {
  /** @deprecated use `ChequeCreateFrom$inboundSchema` instead. */
  export const inboundSchema = ChequeCreateFrom$inboundSchema;
  /** @deprecated use `ChequeCreateFrom$outboundSchema` instead. */
  export const outboundSchema = ChequeCreateFrom$outboundSchema;
  /** @deprecated use `ChequeCreateFrom$Outbound` instead. */
  export type Outbound = ChequeCreateFrom$Outbound;
}

export function chequeCreateFromToJSON(
  chequeCreateFrom: ChequeCreateFrom,
): string {
  return JSON.stringify(
    ChequeCreateFrom$outboundSchema.parse(chequeCreateFrom),
  );
}

export function chequeCreateFromFromJSON(
  jsonString: string,
): SafeParseResult<ChequeCreateFrom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChequeCreateFrom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChequeCreateFrom' from JSON`,
  );
}

/** @internal */
export const RedirectTo$inboundSchema: z.ZodType<
  RedirectTo,
  z.ZodTypeDef,
  unknown
> = z.union([ContactCreate$inboundSchema, z.string()]);

/** @internal */
export type RedirectTo$Outbound = ContactCreate$Outbound | string;

/** @internal */
export const RedirectTo$outboundSchema: z.ZodType<
  RedirectTo$Outbound,
  z.ZodTypeDef,
  RedirectTo
> = z.union([ContactCreate$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RedirectTo$ {
  /** @deprecated use `RedirectTo$inboundSchema` instead. */
  export const inboundSchema = RedirectTo$inboundSchema;
  /** @deprecated use `RedirectTo$outboundSchema` instead. */
  export const outboundSchema = RedirectTo$outboundSchema;
  /** @deprecated use `RedirectTo$Outbound` instead. */
  export type Outbound = RedirectTo$Outbound;
}

export function redirectToToJSON(redirectTo: RedirectTo): string {
  return JSON.stringify(RedirectTo$outboundSchema.parse(redirectTo));
}

export function redirectToFromJSON(
  jsonString: string,
): SafeParseResult<RedirectTo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedirectTo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedirectTo' from JSON`,
  );
}

/** @internal */
export const Size$inboundSchema: z.ZodNativeEnum<typeof Size> = z.nativeEnum(
  Size,
);

/** @internal */
export const Size$outboundSchema: z.ZodNativeEnum<typeof Size> =
  Size$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Size$ {
  /** @deprecated use `Size$inboundSchema` instead. */
  export const inboundSchema = Size$inboundSchema;
  /** @deprecated use `Size$outboundSchema` instead. */
  export const outboundSchema = Size$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodNativeEnum<typeof Two> = z.nativeEnum(Two);

/** @internal */
export const Two$outboundSchema: z.ZodNativeEnum<typeof Two> =
  Two$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
}

/** @internal */
export const CurrencyCode1$inboundSchema: z.ZodNativeEnum<
  typeof CurrencyCode1
> = z.nativeEnum(CurrencyCode1);

/** @internal */
export const CurrencyCode1$outboundSchema: z.ZodNativeEnum<
  typeof CurrencyCode1
> = CurrencyCode1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CurrencyCode1$ {
  /** @deprecated use `CurrencyCode1$inboundSchema` instead. */
  export const inboundSchema = CurrencyCode1$inboundSchema;
  /** @deprecated use `CurrencyCode1$outboundSchema` instead. */
  export const outboundSchema = CurrencyCode1$outboundSchema;
}

/** @internal */
export const CurrencyCode$inboundSchema: z.ZodType<
  CurrencyCode,
  z.ZodTypeDef,
  unknown
> = z.union([CurrencyCode1$inboundSchema, Two$inboundSchema]);

/** @internal */
export type CurrencyCode$Outbound = string | string;

/** @internal */
export const CurrencyCode$outboundSchema: z.ZodType<
  CurrencyCode$Outbound,
  z.ZodTypeDef,
  CurrencyCode
> = z.union([CurrencyCode1$outboundSchema, Two$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CurrencyCode$ {
  /** @deprecated use `CurrencyCode$inboundSchema` instead. */
  export const inboundSchema = CurrencyCode$inboundSchema;
  /** @deprecated use `CurrencyCode$outboundSchema` instead. */
  export const outboundSchema = CurrencyCode$outboundSchema;
  /** @deprecated use `CurrencyCode$Outbound` instead. */
  export type Outbound = CurrencyCode$Outbound;
}

export function currencyCodeToJSON(currencyCode: CurrencyCode): string {
  return JSON.stringify(CurrencyCode$outboundSchema.parse(currencyCode));
}

export function currencyCodeFromJSON(
  jsonString: string,
): SafeParseResult<CurrencyCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CurrencyCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CurrencyCode' from JSON`,
  );
}

/** @internal */
export const ChequeCreate$inboundSchema: z.ZodType<
  ChequeCreate,
  z.ZodTypeDef,
  unknown
> = z.object({
  mergeVariables: z.record(z.any()).optional(),
  description: z.string().optional(),
  metadata: z.record(z.any()).optional(),
  sendDate: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  mailingClass: OrderMailingClass$inboundSchema.optional(),
  to: z.union([ContactCreate$inboundSchema, z.string()]),
  bankAccount: z.string(),
  amount: z.number().int(),
  memo: z.string().optional(),
  message: z.string().optional(),
  logoURL: z.string().optional(),
  number: z.number().int().optional(),
  envelope: z.union([One$inboundSchema, z.string()]).optional(),
  digitalOnly: DigitalOnly$inboundSchema.optional(),
  from: z.union([ContactCreate$inboundSchema, z.string()]),
  redirectTo: z.union([ContactCreate$inboundSchema, z.string()]).optional(),
  size: Size$inboundSchema.default("us_letter"),
  currencyCode: z.union([CurrencyCode1$inboundSchema, Two$inboundSchema])
    .optional(),
});

/** @internal */
export type ChequeCreate$Outbound = {
  mergeVariables?: { [k: string]: any } | undefined;
  description?: string | undefined;
  metadata?: { [k: string]: any } | undefined;
  sendDate?: string | undefined;
  mailingClass?: string | undefined;
  to: ContactCreate$Outbound | string;
  bankAccount: string;
  amount: number;
  memo?: string | undefined;
  message?: string | undefined;
  logoURL?: string | undefined;
  number?: number | undefined;
  envelope?: string | string | undefined;
  digitalOnly?: DigitalOnly$Outbound | undefined;
  from: ContactCreate$Outbound | string;
  redirectTo?: ContactCreate$Outbound | string | undefined;
  size: string;
  currencyCode?: string | string | undefined;
};

/** @internal */
export const ChequeCreate$outboundSchema: z.ZodType<
  ChequeCreate$Outbound,
  z.ZodTypeDef,
  ChequeCreate
> = z.object({
  mergeVariables: z.record(z.any()).optional(),
  description: z.string().optional(),
  metadata: z.record(z.any()).optional(),
  sendDate: z.date().transform(v => v.toISOString()).optional(),
  mailingClass: OrderMailingClass$outboundSchema.optional(),
  to: z.union([ContactCreate$outboundSchema, z.string()]),
  bankAccount: z.string(),
  amount: z.number().int(),
  memo: z.string().optional(),
  message: z.string().optional(),
  logoURL: z.string().optional(),
  number: z.number().int().optional(),
  envelope: z.union([One$outboundSchema, z.string()]).optional(),
  digitalOnly: DigitalOnly$outboundSchema.optional(),
  from: z.union([ContactCreate$outboundSchema, z.string()]),
  redirectTo: z.union([ContactCreate$outboundSchema, z.string()]).optional(),
  size: Size$outboundSchema.default("us_letter"),
  currencyCode: z.union([CurrencyCode1$outboundSchema, Two$outboundSchema])
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeCreate$ {
  /** @deprecated use `ChequeCreate$inboundSchema` instead. */
  export const inboundSchema = ChequeCreate$inboundSchema;
  /** @deprecated use `ChequeCreate$outboundSchema` instead. */
  export const outboundSchema = ChequeCreate$outboundSchema;
  /** @deprecated use `ChequeCreate$Outbound` instead. */
  export type Outbound = ChequeCreate$Outbound;
}

export function chequeCreateToJSON(chequeCreate: ChequeCreate): string {
  return JSON.stringify(ChequeCreate$outboundSchema.parse(chequeCreate));
}

export function chequeCreateFromJSON(
  jsonString: string,
): SafeParseResult<ChequeCreate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChequeCreate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChequeCreate' from JSON`,
  );
}
