/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Cancellation,
  Cancellation$inboundSchema,
  Cancellation$Outbound,
  Cancellation$outboundSchema,
} from "./cancellation.js";
import {
  ChequeSize,
  ChequeSize$inboundSchema,
  ChequeSize$outboundSchema,
} from "./chequesize.js";
import {
  Contact,
  Contact$inboundSchema,
  Contact$Outbound,
  Contact$outboundSchema,
} from "./contact.js";
import {
  DigitalOnly,
  DigitalOnly$inboundSchema,
  DigitalOnly$Outbound,
  DigitalOnly$outboundSchema,
} from "./digitalonly.js";
import {
  OrderIMBStatus,
  OrderIMBStatus$inboundSchema,
  OrderIMBStatus$outboundSchema,
} from "./orderimbstatus.js";
import {
  OrderMailingClass,
  OrderMailingClass$inboundSchema,
  OrderMailingClass$outboundSchema,
} from "./ordermailingclass.js";
import {
  OrderStatus,
  OrderStatus$inboundSchema,
  OrderStatus$outboundSchema,
} from "./orderstatus.js";

/**
 * Always `cheque`.
 */
export const ChequeObject = {
  Cheque: "cheque",
} as const;
/**
 * Always `cheque`.
 */
export type ChequeObject = ClosedEnum<typeof ChequeObject>;

export const Envelope1 = {
  Standard: "standard",
} as const;
export type Envelope1 = ClosedEnum<typeof Envelope1>;

/**
 * The envelope of the cheque. If a custom envelope ID is not specified, defaults to `standard`.
 */
export type ChequeEnvelope = Envelope1 | string;

export const CurrencyCode2 = {
  Cad: "CAD",
} as const;
export type CurrencyCode2 = ClosedEnum<typeof CurrencyCode2>;

export const ChequeCurrencyCode1 = {
  Usd: "USD",
} as const;
export type ChequeCurrencyCode1 = ClosedEnum<typeof ChequeCurrencyCode1>;

/**
 * The currency code of the cheque. This can be `USD` even if drawing from a Canadian bank account and vice versa. Defaults to the currency of the bank account country if not otherwise specified.
 */
export type ChequeCurrencyCode = ChequeCurrencyCode1 | CurrencyCode2;

export type Cheque = {
  /**
   * See `OrderStatus` for more details on the status of this order.
   */
  status: OrderStatus;
  /**
   * These will be merged with the variables in the template or HTML you create this order with. The keys in this object should match the variable names in the template _exactly_ as they are case-sensitive. Note that these _do not_ apply to PDFs uploaded with the order.
   */
  mergeVariables?: { [k: string]: any } | undefined;
  /**
   * The tracking number of this order. Populated after an express/certified order has been processed for delivery.
   */
  trackingNumber?: string | undefined;
  /**
   * The Intelligent Mail Barcode (IMB) status of this order. Only populated for US-printed and US-destined orders. This is the most detailed way to track non-express/certified orders.
   */
  imbStatus?: OrderIMBStatus | undefined;
  /**
   * The most recent ZIP code of the USPS facility that the order has been processed through. Only populated when an `imbStatus` is present.
   */
  imbZIPCode?: string | undefined;
  /**
   * The last date that the IMB status was updated. See `imbStatus` for more details.
   */
  imbDate?: Date | undefined;
  /**
   * The cancellation details of this order. Populated if the order has been cancelled.
   */
  cancellation?: Cancellation | undefined;
  /**
   * PostGrid renders a PDF preview for all orders. This should be inspected to ensure that the order is correct before it is sent out because it shows what will be printed and mailed to the recipient. Once the PDF preview is generated, this field will be returned by all `GET` endpoints which produce this order.
   *
   * @remarks
   *
   * This URL is a signed link to the PDF preview. It will expire after a short period of time. If you need to access this URL after it has expired, you can regenerate it by calling the `GET` endpoint again.
   */
  url?: string | undefined;
  /**
   * A unique ID prefixed with cheque_
   */
  id: string;
  /**
   * An optional string describing this resource. Will be visible in the API and the dashboard.
   */
  description?: string | undefined;
  /**
   * See the section on Metadata.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * `true` if this is a live mode resource else `false`.
   */
  live: boolean;
  /**
   * The UTC time at which this resource was created.
   */
  createdAt: Date;
  /**
   * The UTC time at which this resource was last updated.
   */
  updatedAt: Date;
  /**
   * This order will transition from `ready` to `printing` on the day after this date. For example, if this is a date on Tuesday, the order will transition to `printing` on Wednesday at midnight eastern time.
   */
  sendDate: Date;
  /**
   * The mailing class of this order. This determines the speed and cost of delivery. See `OrderMailingClass` for more details.
   */
  mailingClass: OrderMailingClass;
  /**
   * The recipient of this order. This will be provided even if you delete the underlying contact.
   */
  to: Contact;
  /**
   * Always `cheque`.
   */
  object: ChequeObject;
  /**
   * The bank account (ID) associated with the cheque.
   */
  bankAccount: string;
  /**
   * The amount of the cheque in cents.
   */
  amount: number;
  /**
   * The memo of the cheque.
   */
  memo?: string | undefined;
  /**
   * The message of the cheque.
   */
  message?: string | undefined;
  /**
   * An optional logo URL for the cheque. This will be placed next to the recipient address at the top left corner of the cheque. This needs to be a public link to an image file (e.g. a PNG or JPEG file).
   */
  logoURL?: string | undefined;
  /**
   * The number of the cheque. If you don't provide this, it will automatically be set to an incrementing number starting from 1 across your entire account, ensuring that every cheque has a unique number.
   */
  number?: number | undefined;
  /**
   * The envelope of the cheque. If a custom envelope ID is not specified, defaults to `standard`.
   */
  envelope?: Envelope1 | string | undefined;
  /**
   * The digitalOnly object contains data for digital-only cheques. A watermark must be provided.
   */
  digitalOnly?: DigitalOnly | undefined;
  /**
   * The contact information of the sender.
   */
  from: Contact;
  /**
   * The size of the cheque.
   */
  size: ChequeSize;
  /**
   * The currency code of the cheque. This can be `USD` even if drawing from a Canadian bank account and vice versa. Defaults to the currency of the bank account country if not otherwise specified.
   */
  currencyCode: ChequeCurrencyCode1 | CurrencyCode2;
  /**
   * A link to the deposit-ready PDF for a digital-only cheque, returned if requested and available.
   */
  depositReadyPDFURL?: string | undefined;
};

/** @internal */
export const ChequeObject$inboundSchema: z.ZodNativeEnum<typeof ChequeObject> =
  z.nativeEnum(ChequeObject);

/** @internal */
export const ChequeObject$outboundSchema: z.ZodNativeEnum<typeof ChequeObject> =
  ChequeObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeObject$ {
  /** @deprecated use `ChequeObject$inboundSchema` instead. */
  export const inboundSchema = ChequeObject$inboundSchema;
  /** @deprecated use `ChequeObject$outboundSchema` instead. */
  export const outboundSchema = ChequeObject$outboundSchema;
}

/** @internal */
export const Envelope1$inboundSchema: z.ZodNativeEnum<typeof Envelope1> = z
  .nativeEnum(Envelope1);

/** @internal */
export const Envelope1$outboundSchema: z.ZodNativeEnum<typeof Envelope1> =
  Envelope1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Envelope1$ {
  /** @deprecated use `Envelope1$inboundSchema` instead. */
  export const inboundSchema = Envelope1$inboundSchema;
  /** @deprecated use `Envelope1$outboundSchema` instead. */
  export const outboundSchema = Envelope1$outboundSchema;
}

/** @internal */
export const ChequeEnvelope$inboundSchema: z.ZodType<
  ChequeEnvelope,
  z.ZodTypeDef,
  unknown
> = z.union([Envelope1$inboundSchema, z.string()]);

/** @internal */
export type ChequeEnvelope$Outbound = string | string;

/** @internal */
export const ChequeEnvelope$outboundSchema: z.ZodType<
  ChequeEnvelope$Outbound,
  z.ZodTypeDef,
  ChequeEnvelope
> = z.union([Envelope1$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeEnvelope$ {
  /** @deprecated use `ChequeEnvelope$inboundSchema` instead. */
  export const inboundSchema = ChequeEnvelope$inboundSchema;
  /** @deprecated use `ChequeEnvelope$outboundSchema` instead. */
  export const outboundSchema = ChequeEnvelope$outboundSchema;
  /** @deprecated use `ChequeEnvelope$Outbound` instead. */
  export type Outbound = ChequeEnvelope$Outbound;
}

export function chequeEnvelopeToJSON(chequeEnvelope: ChequeEnvelope): string {
  return JSON.stringify(ChequeEnvelope$outboundSchema.parse(chequeEnvelope));
}

export function chequeEnvelopeFromJSON(
  jsonString: string,
): SafeParseResult<ChequeEnvelope, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChequeEnvelope$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChequeEnvelope' from JSON`,
  );
}

/** @internal */
export const CurrencyCode2$inboundSchema: z.ZodNativeEnum<
  typeof CurrencyCode2
> = z.nativeEnum(CurrencyCode2);

/** @internal */
export const CurrencyCode2$outboundSchema: z.ZodNativeEnum<
  typeof CurrencyCode2
> = CurrencyCode2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CurrencyCode2$ {
  /** @deprecated use `CurrencyCode2$inboundSchema` instead. */
  export const inboundSchema = CurrencyCode2$inboundSchema;
  /** @deprecated use `CurrencyCode2$outboundSchema` instead. */
  export const outboundSchema = CurrencyCode2$outboundSchema;
}

/** @internal */
export const ChequeCurrencyCode1$inboundSchema: z.ZodNativeEnum<
  typeof ChequeCurrencyCode1
> = z.nativeEnum(ChequeCurrencyCode1);

/** @internal */
export const ChequeCurrencyCode1$outboundSchema: z.ZodNativeEnum<
  typeof ChequeCurrencyCode1
> = ChequeCurrencyCode1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeCurrencyCode1$ {
  /** @deprecated use `ChequeCurrencyCode1$inboundSchema` instead. */
  export const inboundSchema = ChequeCurrencyCode1$inboundSchema;
  /** @deprecated use `ChequeCurrencyCode1$outboundSchema` instead. */
  export const outboundSchema = ChequeCurrencyCode1$outboundSchema;
}

/** @internal */
export const ChequeCurrencyCode$inboundSchema: z.ZodType<
  ChequeCurrencyCode,
  z.ZodTypeDef,
  unknown
> = z.union([ChequeCurrencyCode1$inboundSchema, CurrencyCode2$inboundSchema]);

/** @internal */
export type ChequeCurrencyCode$Outbound = string | string;

/** @internal */
export const ChequeCurrencyCode$outboundSchema: z.ZodType<
  ChequeCurrencyCode$Outbound,
  z.ZodTypeDef,
  ChequeCurrencyCode
> = z.union([ChequeCurrencyCode1$outboundSchema, CurrencyCode2$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChequeCurrencyCode$ {
  /** @deprecated use `ChequeCurrencyCode$inboundSchema` instead. */
  export const inboundSchema = ChequeCurrencyCode$inboundSchema;
  /** @deprecated use `ChequeCurrencyCode$outboundSchema` instead. */
  export const outboundSchema = ChequeCurrencyCode$outboundSchema;
  /** @deprecated use `ChequeCurrencyCode$Outbound` instead. */
  export type Outbound = ChequeCurrencyCode$Outbound;
}

export function chequeCurrencyCodeToJSON(
  chequeCurrencyCode: ChequeCurrencyCode,
): string {
  return JSON.stringify(
    ChequeCurrencyCode$outboundSchema.parse(chequeCurrencyCode),
  );
}

export function chequeCurrencyCodeFromJSON(
  jsonString: string,
): SafeParseResult<ChequeCurrencyCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChequeCurrencyCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChequeCurrencyCode' from JSON`,
  );
}

/** @internal */
export const Cheque$inboundSchema: z.ZodType<Cheque, z.ZodTypeDef, unknown> = z
  .object({
    status: OrderStatus$inboundSchema,
    mergeVariables: z.record(z.any()).optional(),
    trackingNumber: z.string().optional(),
    imbStatus: OrderIMBStatus$inboundSchema.optional(),
    imbZIPCode: z.string().optional(),
    imbDate: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
    cancellation: Cancellation$inboundSchema.optional(),
    url: z.string().optional(),
    id: z.string(),
    description: z.string().optional(),
    metadata: z.record(z.any()).optional(),
    live: z.boolean(),
    createdAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    updatedAt: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ),
    sendDate: z.string().datetime({ offset: true }).transform(v => new Date(v)),
    mailingClass: OrderMailingClass$inboundSchema,
    to: Contact$inboundSchema,
    object: ChequeObject$inboundSchema,
    bankAccount: z.string(),
    amount: z.number().int(),
    memo: z.string().optional(),
    message: z.string().optional(),
    logoURL: z.string().optional(),
    number: z.number().int().optional(),
    envelope: z.union([Envelope1$inboundSchema, z.string()]).optional(),
    digitalOnly: DigitalOnly$inboundSchema.optional(),
    from: Contact$inboundSchema,
    size: ChequeSize$inboundSchema,
    currencyCode: z.union([
      ChequeCurrencyCode1$inboundSchema,
      CurrencyCode2$inboundSchema,
    ]),
    depositReadyPDFURL: z.string().optional(),
  });

/** @internal */
export type Cheque$Outbound = {
  status: string;
  mergeVariables?: { [k: string]: any } | undefined;
  trackingNumber?: string | undefined;
  imbStatus?: string | undefined;
  imbZIPCode?: string | undefined;
  imbDate?: string | undefined;
  cancellation?: Cancellation$Outbound | undefined;
  url?: string | undefined;
  id: string;
  description?: string | undefined;
  metadata?: { [k: string]: any } | undefined;
  live: boolean;
  createdAt: string;
  updatedAt: string;
  sendDate: string;
  mailingClass: string;
  to: Contact$Outbound;
  object: string;
  bankAccount: string;
  amount: number;
  memo?: string | undefined;
  message?: string | undefined;
  logoURL?: string | undefined;
  number?: number | undefined;
  envelope?: string | string | undefined;
  digitalOnly?: DigitalOnly$Outbound | undefined;
  from: Contact$Outbound;
  size: string;
  currencyCode: string | string;
  depositReadyPDFURL?: string | undefined;
};

/** @internal */
export const Cheque$outboundSchema: z.ZodType<
  Cheque$Outbound,
  z.ZodTypeDef,
  Cheque
> = z.object({
  status: OrderStatus$outboundSchema,
  mergeVariables: z.record(z.any()).optional(),
  trackingNumber: z.string().optional(),
  imbStatus: OrderIMBStatus$outboundSchema.optional(),
  imbZIPCode: z.string().optional(),
  imbDate: z.date().transform(v => v.toISOString()).optional(),
  cancellation: Cancellation$outboundSchema.optional(),
  url: z.string().optional(),
  id: z.string(),
  description: z.string().optional(),
  metadata: z.record(z.any()).optional(),
  live: z.boolean(),
  createdAt: z.date().transform(v => v.toISOString()),
  updatedAt: z.date().transform(v => v.toISOString()),
  sendDate: z.date().transform(v => v.toISOString()),
  mailingClass: OrderMailingClass$outboundSchema,
  to: Contact$outboundSchema,
  object: ChequeObject$outboundSchema,
  bankAccount: z.string(),
  amount: z.number().int(),
  memo: z.string().optional(),
  message: z.string().optional(),
  logoURL: z.string().optional(),
  number: z.number().int().optional(),
  envelope: z.union([Envelope1$outboundSchema, z.string()]).optional(),
  digitalOnly: DigitalOnly$outboundSchema.optional(),
  from: Contact$outboundSchema,
  size: ChequeSize$outboundSchema,
  currencyCode: z.union([
    ChequeCurrencyCode1$outboundSchema,
    CurrencyCode2$outboundSchema,
  ]),
  depositReadyPDFURL: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Cheque$ {
  /** @deprecated use `Cheque$inboundSchema` instead. */
  export const inboundSchema = Cheque$inboundSchema;
  /** @deprecated use `Cheque$outboundSchema` instead. */
  export const outboundSchema = Cheque$outboundSchema;
  /** @deprecated use `Cheque$Outbound` instead. */
  export type Outbound = Cheque$Outbound;
}

export function chequeToJSON(cheque: Cheque): string {
  return JSON.stringify(Cheque$outboundSchema.parse(cheque));
}

export function chequeFromJSON(
  jsonString: string,
): SafeParseResult<Cheque, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Cheque$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Cheque' from JSON`,
  );
}
